{"version":3,"names":["_helperPluginUtils","require","_utils","_default","exports","default","declare","api","_api$assumption","assertVersion","types","t","noDocumentAll","assumption","name","manipulateOptions","_","parser","plugins","push","visitor","DoExpression","exit","path","node","async","transformDoExpression","doExprPath","doAncestors","WeakSet","add","isFunction","body","get","isArrowFunctionExpression","isExpression","has","replaceWith","blockStatement","returnStatement","flattenStatement","foundDoExpression","deferredPatterns","deferredTemps","param","actualParam","isRestElement","isLValSideEffectFree","pattern","uid","scope","generateUidIdentifier","cloneNode","length","blockBody","isBlockStatement","unshiftContainer","variableDeclaration","variableDeclarator","arrayPattern","arrayExpression","isStatement","parentPath","Error","type","statements","decl","init","id","flattenExpression","flattenLVal","kind","replaceWithMultiple","test","ifStatement","unaryExpression","breakStatement","remove","update","discardResult","set","initNode","expressionStatement","newPath","left","generateDeclaredUidIdentifier","isVariableDeclaration","buildCodeFrameError","newBody","right","booleanLiteral","insertBefore","flattenByTraverse","opts","isTopLevelCopyable","flattenTrailing","hasDoExpression","isDoExpression","completions","getCompletionRecords","filter","completion","isExpressionStatement","assignmentExpression","expression","buildUndefinedNode","isAssignmentExpression","operator","isLogicalExpression","binaryExpression","nullLiteral","logicalExpression","isConditionalExpression","alternate","consequent","conditionalExpression","isOptionalMemberExpression","computed","object","property","buildOptionalChainChecker","memberExpression","isOptionalCallExpression","callee","calleeStatements","callExpression","arguments","callStatements","flattenCallExpression","isCallExpression","intoTempVariable","thisArgument","isMemberExpression","isSuper","arg","isSpreadElement","spreadElement","identifier","thisExpression","wrapDoExpressionInIIFE","elements","element","restElement","expressions","traverse","Statement","skip","Expression","lastDoExpression","pop","statement","isPureish","isBinaryExpression","isParenthesizedExpression","isSequenceExpression","isUnaryExpression","isIdentifier","isAssignmentPattern"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t, NodePath } from \"@babel/core\";\nimport { wrapDoExpressionInIIFE } from \"./utils.ts\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const { types: t } = api;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? false;\n\n  return {\n    name: \"proposal-do-expressions\",\n    manipulateOptions: (_, parser) => parser.plugins.push(\"doExpressions\"),\n\n    visitor: {\n      DoExpression: {\n        exit(path) {\n          if (path.node.async) {\n            // Async do expressions are not yet supported\n            return;\n          }\n          transformDoExpression(path);\n        },\n      },\n    },\n  };\n\n  function transformDoExpression(doExprPath: NodePath<t.DoExpression>) {\n    const doAncestors = new WeakSet<t.Node>();\n    let path: NodePath = doExprPath;\n    while (path) {\n      if (!path.node) return; // This node has been removed due to previous transformation\n      doAncestors.add(path.node);\n      if (path.isFunction()) {\n        let body = path.get(\"body\");\n        if (path.isArrowFunctionExpression()) {\n          // Do expression within parameters declarations OR expression body\n          if (body.isExpression() && doAncestors.has(body.node)) {\n            [body] = body.replaceWith(\n              t.blockStatement([t.returnStatement(body.node)]),\n            );\n            flattenStatement(body.get(\"body\")[0]);\n          }\n        }\n\n        // Do expression within function parameter lists\n        let foundDoExpression = false;\n        const deferredPatterns: t.LVal[] = [];\n        const deferredTemps: t.Identifier[] = [];\n        for (const param of path.get(\"params\")) {\n          const actualParam = param.isRestElement()\n            ? param.get(\"argument\")\n            : param;\n          foundDoExpression ||= doAncestors.has(actualParam.node);\n          if (foundDoExpression && !isLValSideEffectFree(actualParam)) {\n            const pattern = actualParam.node;\n            const uid = body.scope.generateUidIdentifier(\"do\");\n            actualParam.replaceWith(t.cloneNode(uid));\n            deferredPatterns.push(pattern);\n            deferredTemps.push(uid);\n          }\n        }\n        if (deferredPatterns.length) {\n          let blockBody: NodePath<t.BlockStatement>;\n          if (body.isBlockStatement()) {\n            blockBody = body;\n          } else {\n            [blockBody] = body.replaceWith(\n              t.blockStatement([t.returnStatement(body.node)]),\n            );\n          }\n\n          blockBody.unshiftContainer(\n            \"body\",\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(\n                t.arrayPattern(deferredPatterns),\n                t.arrayExpression(deferredTemps),\n              ),\n            ]),\n          );\n          flattenStatement(blockBody.get(\"body\")[0]);\n        }\n        return;\n      }\n      if (path.isStatement()) {\n        // Flatten the closest parent statement\n        flattenStatement(path);\n        return;\n      }\n      path = path.parentPath;\n    }\n    throw new Error(\n      \"Internal error: DoExpression must be in a statement. This is a Babel bug, please report it.\",\n    );\n\n    function flattenStatement(path: NodePath<t.Statement>) {\n      switch (path.type) {\n        case \"VariableDeclaration\": {\n          const statements: t.Statement[] = [];\n          for (const decl of path.get(\"declarations\")) {\n            const init = decl.get(\"init\");\n            const id = decl.get(\"id\");\n            if (doAncestors.has(init.node)) {\n              statements.push(...flattenExpression(init));\n            }\n            if (doAncestors.has(id.node)) {\n              statements.push(...flattenLVal(id, init.node, path.node.kind));\n            } else {\n              statements.push(\n                t.variableDeclaration(path.node.kind, [decl.node]),\n              );\n            }\n          }\n          path.replaceWithMultiple(statements);\n          break;\n        }\n        case \"ForStatement\": {\n          // Example:       for (var i = do { f1(); }; do { f2(); }; do { f3(); }) { ... }\n          // Transform to:  var temp1 = f1();\n          //                for (var i = temp1; ;) {\n          //                  var temp2 = f2();\n          //                  if (!temp2) break;\n          //                  ...\n          //                  f3();\n          //                }\n          const body: t.Statement[] = [];\n          const test = path.get(\"test\");\n          if (doAncestors.has(test.node)) {\n            body.push(\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n            );\n            test.remove();\n          }\n          body.push(path.node.body);\n          const update = path.get(\"update\");\n          if (doAncestors.has(update.node)) {\n            body.push(...flattenExpression(update, { discardResult: true }));\n            update.remove();\n          }\n          path.set(\"body\", t.blockStatement(body));\n\n          // Handle do expression within `init`\n          const init = path.get(\"init\");\n          if (doAncestors.has(init.node)) {\n            const initNode = init.isExpression()\n              ? t.expressionStatement(init.node)\n              : init.node;\n            init.remove();\n            const [newPath] = path.replaceWith(\n              t.blockStatement([initNode, path.node]),\n            );\n            flattenStatement(newPath.get(\"body\")[0]);\n          }\n          break;\n        }\n        case \"ForInStatement\":\n        case \"ForOfStatement\": {\n          // Example:       for (const i in do { f1(); }) { ... }\n          // Transform to:  var temp1 = f1();\n          //                for (var temp2 in temp1) {\n          //                  const i = temp2;\n          //                  ...\n          //                }\n\n          // Handle left side\n          const left = path.get(\"left\");\n          if (doAncestors.has(left.node)) {\n            const body = path.get(\"body\");\n            const uid = body.scope.generateDeclaredUidIdentifier(\"do\");\n            if (left.isVariableDeclaration()) {\n              const init = left.get(\"declarations\")[0].get(\"init\");\n              if (init.node) {\n                throw init.buildCodeFrameError(\n                  \"Complex variable declaration in for-in with do expression is not currently supported\",\n                );\n              }\n              init.replaceWith(t.cloneNode(uid));\n              const [newBody] = body.replaceWith(\n                t.blockStatement([left.node, body.node]),\n              );\n              flattenStatement(newBody.get(\"body\")[0]);\n            } else {\n              body.replaceWith(\n                t.blockStatement([\n                  ...flattenLVal(left, t.cloneNode(uid), null),\n                  body.node,\n                ]),\n              );\n            }\n            left.replaceWith(uid);\n          }\n\n          // Handle right side\n          const right = path.get(\"right\");\n          if (doAncestors.has(right.node)) {\n            path.replaceWithMultiple([...flattenExpression(right), path.node]);\n          }\n          break;\n        }\n        case \"WhileStatement\": {\n          // Example:      while (do { foo(); }) { ... }\n          // Transform to: while (true) { var temp = foo(); if (!temp) break; ... }\n          const test = path.get(\"test\");\n          path.set(\n            \"body\",\n            t.blockStatement([\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n              path.node.body,\n            ]),\n          );\n          test.replaceWith(t.booleanLiteral(true));\n          break;\n        }\n        case \"DoWhileStatement\": {\n          // Example:      do { ... } while (do { foo(); })\n          // Transform to: do { ...; var temp = foo(); if (!temp) break; } while (true)\n          const test = path.get(\"test\");\n          path.set(\n            \"body\",\n            t.blockStatement([\n              path.node.body,\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n            ]),\n          );\n          test.replaceWith(t.booleanLiteral(true));\n          break;\n        }\n        case \"ExpressionStatement\":\n          path.replaceWithMultiple(\n            flattenExpression(path.get(\"expression\"), { discardResult: true }),\n          );\n          break;\n        default:\n          path.insertBefore(flattenByTraverse(path));\n      }\n    }\n\n    function flattenExpression(\n      path: NodePath<t.Expression>,\n      opts: {\n        flattenTrailing?: boolean;\n        discardResult?: boolean;\n      } = {},\n    ): t.Statement[] {\n      if (isTopLevelCopyable(path)) {\n        return flattenByTraverse(path, opts.flattenTrailing);\n      }\n      const hasDoExpression = doAncestors.has(path.node);\n      if (hasDoExpression) {\n        if (path.isDoExpression()) {\n          const body = path.get(\"body\");\n          if (!opts.discardResult) {\n            const completions = body\n              .getCompletionRecords(/* shouldPreserveBreak */ true)\n              .filter(completion => completion.isExpressionStatement());\n            if (completions.length) {\n              const uid = body.scope.generateDeclaredUidIdentifier(\"do\");\n              for (const completion of completions) {\n                completion.replaceWith(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(uid),\n                    completion.node.expression,\n                  ),\n                );\n              }\n              path.replaceWith(uid);\n            } else {\n              path.replaceWith(path.scope.buildUndefinedNode());\n            }\n          }\n          return [body.node];\n        } else if (path.isAssignmentExpression()) {\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          if (doAncestors.has(left.node)) {\n            if (path.node.operator !== \"=\") {\n              throw path.buildCodeFrameError(\n                \"Do expression inside complex assignment expression is not currently supported\",\n              );\n            }\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            path.replaceWith(uid);\n            return [\n              ...flattenExpression(right),\n              ...flattenLVal(left, right.node, null),\n            ];\n          }\n        } else if (path.isLogicalExpression()) {\n          const operator = path.node.operator;\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          const statements = [\n            ...flattenExpression(left),\n            t.ifStatement(\n              operator === \"&&\"\n                ? t.cloneNode(left.node)\n                : operator === \"||\"\n                  ? t.unaryExpression(\"!\", t.cloneNode(left.node))\n                  : t.binaryExpression(\n                      \"==\",\n                      t.cloneNode(left.node),\n                      t.nullLiteral(),\n                    ),\n              t.blockStatement(flattenExpression(right)),\n            ),\n          ];\n          path.replaceWith(\n            t.logicalExpression(path.node.operator, left.node, right.node),\n          );\n          return statements;\n        } else if (path.isConditionalExpression()) {\n          const test = path.get(\"test\");\n          const alternate = path.get(\"alternate\");\n          const consequent = path.get(\"consequent\");\n          const statements = [\n            ...flattenExpression(test),\n            t.ifStatement(\n              t.cloneNode(test.node),\n              t.blockStatement(flattenExpression(consequent)),\n              t.blockStatement(flattenExpression(alternate)),\n            ),\n          ];\n          path.replaceWith(\n            t.conditionalExpression(test.node, consequent.node, alternate.node),\n          );\n          return statements;\n        } else if (path.isOptionalMemberExpression() && path.node.computed) {\n          const object = path.get(\"object\");\n          const property = path.get(\"property\");\n          const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n          path.replaceWith(uid);\n          return [\n            ...flattenExpression(object),\n            t.ifStatement(\n              buildOptionalChainChecker(object.node),\n              t.blockStatement([\n                ...flattenExpression(property),\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(uid),\n                    t.memberExpression(\n                      object.node,\n                      property.node,\n                      true /* computed */,\n                    ),\n                  ),\n                ),\n              ]),\n            ),\n          ];\n        } else if (path.isOptionalCallExpression()) {\n          const callee = path.get(\"callee\");\n          const calleeStatements = flattenExpression(callee);\n          const [newPath] = path.replaceWith(\n            t.callExpression(t.cloneNode(callee.node), path.node.arguments),\n          );\n          const callStatements = flattenCallExpression(\n            newPath,\n            opts.discardResult,\n          );\n          return [\n            ...calleeStatements,\n            t.ifStatement(\n              buildOptionalChainChecker(callee.node),\n              t.blockStatement(callStatements),\n            ),\n          ];\n        } else if (path.isCallExpression()) {\n          return flattenCallExpression(path, opts.discardResult);\n        }\n      }\n\n      if (hasDoExpression) {\n        return [\n          ...flattenByTraverse(path, opts.flattenTrailing),\n          intoTempVariable(path, opts.discardResult),\n        ];\n      } else {\n        return [intoTempVariable(path, opts.discardResult)];\n      }\n    }\n\n    function flattenCallExpression(\n      path: NodePath<t.CallExpression>,\n      discardResult?: boolean,\n    ): t.Statement[] {\n      const callee = path.get(\"callee\");\n      let thisArgument: NodePath<t.Expression | t.Super> | undefined;\n      const statements = [];\n      if (callee.isMemberExpression()) {\n        thisArgument = callee.get(\"object\");\n        if (!thisArgument.isSuper()) {\n          statements.push(...flattenExpression(thisArgument));\n        }\n      }\n      statements.push(...flattenExpression(callee as NodePath<t.Expression>));\n\n      for (const arg of path.get(\"arguments\")) {\n        if (arg.isSpreadElement()) {\n          const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n          statements.push(\n            ...flattenExpression(arg.get(\"argument\")),\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.cloneNode(uid),\n                t.arrayExpression([arg.node]),\n              ),\n            ),\n          );\n          arg.replaceWith(t.spreadElement(uid));\n        } else {\n          statements.push(...flattenExpression(arg as NodePath<t.Expression>));\n        }\n      }\n\n      if (thisArgument) {\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(\n              path.node.callee as t.Expression,\n              t.identifier(\"call\"),\n            ),\n            [\n              thisArgument.isSuper()\n                ? t.thisExpression()\n                : t.cloneNode(thisArgument.node),\n              ...(path.node.arguments as Array<t.Expression | t.SpreadElement>),\n            ],\n          ),\n        );\n        return [...statements, intoTempVariable(path, discardResult)];\n      } else {\n        path.replaceWith(t.callExpression(callee.node, path.node.arguments));\n      }\n      return [...statements, intoTempVariable(path, discardResult)];\n    }\n\n    function flattenLVal(\n      path: NodePath<t.LVal | t.OptionalMemberExpression>,\n      init: t.Expression | null | undefined,\n      declare: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\" | null,\n    ): t.Statement[] {\n      switch (path.type) {\n        case \"ObjectPattern\": {\n          wrapDoExpressionInIIFE(path);\n          // Fallthrough\n        }\n        case \"Identifier\": {\n          if (declare) {\n            return [\n              t.variableDeclaration(declare, [\n                t.variableDeclarator(path.node, init),\n              ]),\n            ];\n          } else {\n            return [\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", path.node, init),\n              ),\n            ];\n          }\n        }\n        case \"MemberExpression\": {\n          return [\n            ...flattenByTraverse(path),\n            t.expressionStatement(t.assignmentExpression(\"=\", path.node, init)),\n          ];\n        }\n        case \"AssignmentPattern\": {\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          if (init) {\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            return [\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", t.cloneNode(uid), init),\n              ),\n              t.ifStatement(\n                t.binaryExpression(\n                  \"===\",\n                  t.cloneNode(uid),\n                  t.buildUndefinedNode(),\n                ),\n                t.blockStatement([\n                  ...flattenExpression(right),\n                  t.expressionStatement(\n                    t.assignmentExpression(\"=\", t.cloneNode(uid), right.node),\n                  ),\n                ]),\n              ),\n              ...flattenLVal(left, uid, declare),\n            ];\n          } else {\n            return flattenLVal(path.get(\"left\"), right.node, declare);\n          }\n        }\n        case \"ArrayPattern\": {\n          const elements: t.ArrayPattern[\"elements\"] = [];\n          const statements: t.Statement[] = [];\n          for (const element of path.get(\"elements\")) {\n            if (!element.type || isLValSideEffectFree(element)) {\n              elements.push(element.node);\n              continue;\n            }\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            if (element.isRestElement()) {\n              elements.push(t.restElement(t.cloneNode(uid)));\n              statements.push(\n                ...flattenLVal(element.get(\"argument\"), uid, declare),\n              );\n            } else {\n              elements.push(t.cloneNode(uid));\n              statements.push(...flattenLVal(element, uid, declare));\n            }\n          }\n          return [\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", t.arrayPattern(elements), init),\n            ),\n            ...statements,\n          ];\n        }\n        default: {\n          throw path.buildCodeFrameError(\n            `Do expression inside ${path.type} is not currently supported`,\n          );\n        }\n      }\n    }\n\n    function flattenByTraverse(\n      path: NodePath,\n      flattenTrailing?: boolean,\n    ): t.Statement[] {\n      // Collect immediate descendant expressions\n      const expressions: NodePath<t.Expression>[] = [];\n      path.traverse({\n        Statement(path) {\n          path.skip();\n        },\n        Expression(path) {\n          expressions.push(path);\n          path.skip();\n        },\n      });\n\n      // Skip flattening trailing expressions that are after all the DoExpressions\n      let lastDoExpression: NodePath<t.Expression>;\n      if (!flattenTrailing) {\n        while (expressions.length) {\n          const path = expressions.pop();\n          if (doAncestors.has(path.node)) {\n            lastDoExpression = path;\n            break;\n          }\n        }\n      }\n\n      // Flatten the expressions\n      const statements: t.Statement[] = [];\n      for (const path of expressions) {\n        statements.push(...flattenExpression(path, { flattenTrailing: true }));\n      }\n      if (lastDoExpression) {\n        statements.push(...flattenExpression(lastDoExpression));\n      }\n      return statements;\n    }\n\n    function intoTempVariable(\n      path: NodePath<t.Expression>,\n      discardResult?: boolean,\n    ): t.Statement {\n      if (discardResult) {\n        return t.expressionStatement(path.node);\n      } else {\n        const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n        const statement = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(uid), path.node),\n        );\n        path.replaceWith(uid);\n        return statement;\n      }\n    }\n  }\n\n  function buildOptionalChainChecker(node: t.Expression) {\n    if (noDocumentAll) {\n      return t.binaryExpression(\"!=\", t.cloneNode(node), t.nullLiteral());\n    } else {\n      return t.logicalExpression(\n        \"&&\",\n        t.binaryExpression(\"!==\", t.cloneNode(node), t.nullLiteral()),\n        t.binaryExpression(\"!==\", t.cloneNode(node), t.buildUndefinedNode()),\n      );\n    }\n  }\n});\n\nfunction isTopLevelCopyable(path: NodePath<t.Node>): boolean {\n  return (\n    path.isPureish() ||\n    path.isBinaryExpression() ||\n    path.isParenthesizedExpression() ||\n    path.isSequenceExpression() ||\n    (path.isUnaryExpression() &&\n      path.node.operator !== \"throw\" &&\n      path.node.operator !== \"delete\")\n  );\n}\n\nfunction isLValSideEffectFree(path: NodePath<t.Node>): boolean {\n  return (\n    path.isIdentifier() ||\n    (path.isAssignmentPattern() &&\n      isLValSideEffectFree(path.get(\"left\")) &&\n      path.get(\"right\").isPureish()) ||\n    (path.isRestElement() && isLValSideEffectFree(path.get(\"argument\")))\n  );\n}\n"],"mappings":"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","ignoreList":[]}